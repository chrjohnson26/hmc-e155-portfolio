[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Lab Two Reflection\n\n\nTime Multiplexing\n\n\n\n\n\nSep 9, 2025\n\n\nChristian Johnson\n\n\n\n\n\n\n\n\n\n\n\n\nLab One Reflection\n\n\nLife After MicroPs Lab 1\n\n\n\n\n\nSep 2, 2025\n\n\nChristian Johnson\n\n\n\n\n\n\n\n\n\n\n\n\nHello e155\n\n\nWelcome to my MicroPs blog!\n\n\n\n\n\nAug 26, 2025\n\n\nChristian Johnson\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Christian Johnson is in his final year of undergrad at Harvey Mudd studying Computer Science and Mathematics. This past summer Christian worked at Walmart, where he integrated AI into existing workflows by building MCP servers. Some of his favorite classes so far include Network Science, Algorithms, and Machine Learning."
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Hello e155",
    "section": "",
    "text": "This is the first week of the Fall 2025 semester. I’ve just finished configuring the MicroPs quarto page. Here are a couple goals I have for myself this semester:\n\nGet better with hands on skills like soldering and making clean circuits\nBecome confident with working with new hardware\nProficency in reading data sheets and other documentation"
  },
  {
    "objectID": "posts/week1.html",
    "href": "posts/week1.html",
    "title": "Lab One Reflection",
    "section": "",
    "text": "Hi,\nI just finished the proficiency specs for Lab 1. Overall, I feel good about the work I did, but there are definitely areas where I can improve. One of the biggest challenges I faced was getting the testbench working. I spent a lot of time debugging the Verilog code and my circuit itself, but in the end, I was able to get it working. If I was able to get my testbench working I would have been able to get all the specs on the lab and have an easier time with debugging.\nLooking ahead, I want to focus on improving my debugging skills and becoming more comfortable with the tools we are using in this class. I also want to make sure I am keeping up with the checkpoints / specs for the lab, as I know that staying organized and on time is really important for this class.\nFinally, I just wanted to note that I don’t think I’ve ever spent this much time on one assignment at Harvey Mudd and I’m gonna need to ramp up quickly or figure something out."
  },
  {
    "objectID": "posts/week2.html",
    "href": "posts/week2.html",
    "title": "Lab Two Reflection",
    "section": "",
    "text": "This past week I learned about time multiplexing and how to use it to drive multiple 7-segment displays with a single set of segment control lines. This technique is essential for reducing the number of I/O pins required on the FPGA, which is particularly important when working with limited resources. By rapidly switching between the displays, we can create the illusion that all displays are lit simultaneously.\nThis week I made sure to get my test benches done right after finishing my modules. Since last week I struggled to get them working. However, this week it wasn’t the testbenches that gave me trouble but rather getting the hardware to work. Even now my two segments aren’t working correctly. This just reminds me that nothing in microps is “easy”."
  },
  {
    "objectID": "labs.html",
    "href": "labs.html",
    "title": "E155 Labs",
    "section": "",
    "text": "In this lab I implemented a design on the FPGA board to demonstrate the functionality of the on-board high-speed oscillator, LEDs, and the 7-segment display. The high speed oscillator was configured and divided down using a counter to achieve a blinking frequency of ~2.4 Hz. Combinational logic was used to control the 7-segment display and other LEDs based on the counter output.\n\n\n\nThe design was implemented using Verilog and tested on the FPGA board. The high-speed oscillator was configured to drive the blinking LED. Combinational logic was used to control the 7-segment display and other LEDs based on the provided truth tables. The design was tested by observing the oscilloscope trace of the blinking LED and checking all input combinations for the 7-segment display output and other LEDs.\n\n\n\nThe source code for my project can be found at this GitHub repository.\n\n\n\n\n\nBlock Diagram for Verilog Design\n\n\nThe block diagram illustrates the overall architecture of the design, including the connections between the FPGA, 7-segment display, and LEDs. The top-level module lab1_CJ is responsible for instantiating and connecting all the sub-modules. The submodules (led_controller and segment) include the logic for controlling the LEDs and the 7-segment display, respectively.\n\n\n\n\n\n\nPhysical Schematic of Circuit\n\n\nThe schematic provides a detailed view of the physical connections between the FPGA, 7-segment display, and LEDs. Each switch has a 100k\\(\\ohm\\) pull-up resistor to ensure a defined logic level when the switch is open. The 7-segment display is connected to the FPGA through 162\\(\\ohm\\) current-limiting resistors to ensure current draw within the recommended range. The surface mount LEDs are connected in series with 1k\\(\\ohm\\) resistors to limit the current to a safe level.\nAccording to the data sheet for the Segment Display, the forward voltage is 2.0V. According to the lab manual the ideal current range is between 5-20mA. This means that the 162\\(\\ohm\\) resistors must ensure that the current through the display remains within this range. Given that the 3.3V supply voltage is used, we can calculate the current through the display as follows:\n\\[\nI = \\frac{V}{R} = \\frac{3.3V - 2.0V}{162 \\ohm} \\approx 8.13mA\n\\]\n\n\n\n\nThis lab meets all intended proficiency and excellence specifications. The design was successfully implemented and tested on the FPGA board, demonstrating the functionality of the high-speed oscillator, LEDs, and 7-segment display. The oscilloscope trace confirmed the expected blinking frequency of ~2.4 Hz for the LED, and all input combinations for the 7-segment display were verified against the truth tables.\nBelow the are screenshots from ModelSim showing the simulation results for the top module and each submodule. \n\n\n\nScreenshot of Questa ModelSim Simulation for lab1_CJ top module\n\n\n\n\n\nScreenshot of Questa ModelSim Simulation for segment module\n\n\n\n\n\nScreenshot of Questa ModelSim Simulation for led_controller module\n\n\nThe three screenshots above show the simulation results for the top module (lab1_CJ) and each submodule (segment and led_controller). The waveforms indicate that the design behaves as expected, with the surface mount LEDs and the 7-segment display and other LEDs responding correctly to the input combinations.\n\n\n\n\nThe design successfully demonstrated the functionality of the high-speed oscillator, LEDs, and 7-segment display on the FPGA board. The implementation met all proficiency specifications, and the testing methodology verified the design against the provided requirements by checking all possible input combinations. Unfortunately, I was not able to complete the testbench but intend on doing so in the future. I spent roughly 27 hours on this lab.\n\n\n\nThe first AI Prototype query I made was to Google Gemini 2.5 Pro. It generated a single module which implements a simple LED blinking functionality using a high-speed oscillator. However, when synthesizing I got an error that the module OSCH was unknown. After asking GPT-4.1 to debug this it gave me several suggestion on how to resolve the error in synthesis.\n\n\nHere is the System Verilog file Gemini generated:\n/**\n * @brief Blinks an LED at 2 Hz using the internal 48 MHz oscillator.\n * @details This module is designed for a Lattice iCE40 UP5K FPGA.\n *          It instantiates the internal high-speed oscillator (OSCH) to generate a\n *          48 MHz clock. A counter then divides this clock to toggle an LED\n *          output at a frequency of 2 Hz (0.25s on, 0.25s off).\n *\n * @param CLK_FREQ The frequency of the internal oscillator in Hz.\n * @param BLINK_FREQ The desired blink frequency of the LED in Hz.\n */\nmodule led_blinker #(\n    parameter CLK_FREQ   = 48_000_000, // 48 MHz clock frequency\n    parameter BLINK_FREQ = 2           // 2 Hz blink frequency\n) (\n    output logic led_o // LED output\n);\n\n    // The division factor needed to get one toggle every half-period.\n    // (CLK_FREQ / BLINK_FREQ) gives the counts for a full cycle (on and off).\n    // We want to toggle at half the cycle period.\n    localparam HALF_PERIOD_COUNTS = CLK_FREQ / (BLINK_FREQ * 2);\n\n    // Calculate the number of bits required for the counter.\n    // $clog2 calculates the ceiling of log base 2, which gives the bit-width.\n    localparam COUNTER_WIDTH = $clog2(HALF_PERIOD_COUNTS);\n\n    // Internal high-frequency clock signal\n    logic hf_clk;\n\n    // Counter to divide the clock frequency\n    logic [COUNTER_WIDTH-1:0] counter;\n\n    // Instantiate the Lattice iCE40 UltraPlus internal high-speed oscillator.\n    // This generates the main clock for our logic without needing an external crystal.\n    OSCH #(\n        .NOM_FREQ(\"48.00\") // Specify nominal frequency in MHz. Other options: \"12.00\", \"24.00\", \"36.00\"\n    ) u_osc (\n        .STDBY(1'b0),      // Oscillator is not in standby\n        .HFOSCEN(1'b1),    // High Frequency Oscillator is enabled\n        .CHIPCLKEN(1'b1),  // Clock enable for the CHIPCLK-pin\n        .HFOSCOUT(hf_clk)  // High Frequency Oscillator output\n    );\n\n    // Synchronous logic for the counter and LED toggle.\n    // This block is sensitive to the rising edge of the high-frequency clock.\n    always_ff @(posedge hf_clk) begin\n        if (counter == HALF_PERIOD_COUNTS - 1) begin\n            counter &lt;= '0;        // Reset the counter\n            led_o   &lt;= ~led_o;    // Toggle the LED state\n        end else begin\n            counter &lt;= counter + 1; // Increment the counter\n        end\n    end\n\n    // Set the initial state of the LED and counter.\n    initial begin\n        led_o   = 1'b0;\n        counter = '0;\n    end\n\nendmodule"
  },
  {
    "objectID": "labs.html#lab-1---board-assembly-and-testing",
    "href": "labs.html#lab-1---board-assembly-and-testing",
    "title": "E155 Labs",
    "section": "",
    "text": "In this lab I implemented a design on the FPGA board to demonstrate the functionality of the on-board high-speed oscillator, LEDs, and the 7-segment display. The high speed oscillator was configured and divided down using a counter to achieve a blinking frequency of ~2.4 Hz. Combinational logic was used to control the 7-segment display and other LEDs based on the counter output.\n\n\n\nThe design was implemented using Verilog and tested on the FPGA board. The high-speed oscillator was configured to drive the blinking LED. Combinational logic was used to control the 7-segment display and other LEDs based on the provided truth tables. The design was tested by observing the oscilloscope trace of the blinking LED and checking all input combinations for the 7-segment display output and other LEDs.\n\n\n\nThe source code for my project can be found at this GitHub repository.\n\n\n\n\n\nBlock Diagram for Verilog Design\n\n\nThe block diagram illustrates the overall architecture of the design, including the connections between the FPGA, 7-segment display, and LEDs. The top-level module lab1_CJ is responsible for instantiating and connecting all the sub-modules. The submodules (led_controller and segment) include the logic for controlling the LEDs and the 7-segment display, respectively.\n\n\n\n\n\n\nPhysical Schematic of Circuit\n\n\nThe schematic provides a detailed view of the physical connections between the FPGA, 7-segment display, and LEDs. Each switch has a 100k\\(\\ohm\\) pull-up resistor to ensure a defined logic level when the switch is open. The 7-segment display is connected to the FPGA through 162\\(\\ohm\\) current-limiting resistors to ensure current draw within the recommended range. The surface mount LEDs are connected in series with 1k\\(\\ohm\\) resistors to limit the current to a safe level.\nAccording to the data sheet for the Segment Display, the forward voltage is 2.0V. According to the lab manual the ideal current range is between 5-20mA. This means that the 162\\(\\ohm\\) resistors must ensure that the current through the display remains within this range. Given that the 3.3V supply voltage is used, we can calculate the current through the display as follows:\n\\[\nI = \\frac{V}{R} = \\frac{3.3V - 2.0V}{162 \\ohm} \\approx 8.13mA\n\\]\n\n\n\n\nThis lab meets all intended proficiency and excellence specifications. The design was successfully implemented and tested on the FPGA board, demonstrating the functionality of the high-speed oscillator, LEDs, and 7-segment display. The oscilloscope trace confirmed the expected blinking frequency of ~2.4 Hz for the LED, and all input combinations for the 7-segment display were verified against the truth tables.\nBelow the are screenshots from ModelSim showing the simulation results for the top module and each submodule. \n\n\n\nScreenshot of Questa ModelSim Simulation for lab1_CJ top module\n\n\n\n\n\nScreenshot of Questa ModelSim Simulation for segment module\n\n\n\n\n\nScreenshot of Questa ModelSim Simulation for led_controller module\n\n\nThe three screenshots above show the simulation results for the top module (lab1_CJ) and each submodule (segment and led_controller). The waveforms indicate that the design behaves as expected, with the surface mount LEDs and the 7-segment display and other LEDs responding correctly to the input combinations.\n\n\n\n\nThe design successfully demonstrated the functionality of the high-speed oscillator, LEDs, and 7-segment display on the FPGA board. The implementation met all proficiency specifications, and the testing methodology verified the design against the provided requirements by checking all possible input combinations. Unfortunately, I was not able to complete the testbench but intend on doing so in the future. I spent roughly 27 hours on this lab.\n\n\n\nThe first AI Prototype query I made was to Google Gemini 2.5 Pro. It generated a single module which implements a simple LED blinking functionality using a high-speed oscillator. However, when synthesizing I got an error that the module OSCH was unknown. After asking GPT-4.1 to debug this it gave me several suggestion on how to resolve the error in synthesis.\n\n\nHere is the System Verilog file Gemini generated:\n/**\n * @brief Blinks an LED at 2 Hz using the internal 48 MHz oscillator.\n * @details This module is designed for a Lattice iCE40 UP5K FPGA.\n *          It instantiates the internal high-speed oscillator (OSCH) to generate a\n *          48 MHz clock. A counter then divides this clock to toggle an LED\n *          output at a frequency of 2 Hz (0.25s on, 0.25s off).\n *\n * @param CLK_FREQ The frequency of the internal oscillator in Hz.\n * @param BLINK_FREQ The desired blink frequency of the LED in Hz.\n */\nmodule led_blinker #(\n    parameter CLK_FREQ   = 48_000_000, // 48 MHz clock frequency\n    parameter BLINK_FREQ = 2           // 2 Hz blink frequency\n) (\n    output logic led_o // LED output\n);\n\n    // The division factor needed to get one toggle every half-period.\n    // (CLK_FREQ / BLINK_FREQ) gives the counts for a full cycle (on and off).\n    // We want to toggle at half the cycle period.\n    localparam HALF_PERIOD_COUNTS = CLK_FREQ / (BLINK_FREQ * 2);\n\n    // Calculate the number of bits required for the counter.\n    // $clog2 calculates the ceiling of log base 2, which gives the bit-width.\n    localparam COUNTER_WIDTH = $clog2(HALF_PERIOD_COUNTS);\n\n    // Internal high-frequency clock signal\n    logic hf_clk;\n\n    // Counter to divide the clock frequency\n    logic [COUNTER_WIDTH-1:0] counter;\n\n    // Instantiate the Lattice iCE40 UltraPlus internal high-speed oscillator.\n    // This generates the main clock for our logic without needing an external crystal.\n    OSCH #(\n        .NOM_FREQ(\"48.00\") // Specify nominal frequency in MHz. Other options: \"12.00\", \"24.00\", \"36.00\"\n    ) u_osc (\n        .STDBY(1'b0),      // Oscillator is not in standby\n        .HFOSCEN(1'b1),    // High Frequency Oscillator is enabled\n        .CHIPCLKEN(1'b1),  // Clock enable for the CHIPCLK-pin\n        .HFOSCOUT(hf_clk)  // High Frequency Oscillator output\n    );\n\n    // Synchronous logic for the counter and LED toggle.\n    // This block is sensitive to the rising edge of the high-frequency clock.\n    always_ff @(posedge hf_clk) begin\n        if (counter == HALF_PERIOD_COUNTS - 1) begin\n            counter &lt;= '0;        // Reset the counter\n            led_o   &lt;= ~led_o;    // Toggle the LED state\n        end else begin\n            counter &lt;= counter + 1; // Increment the counter\n        end\n    end\n\n    // Set the initial state of the LED and counter.\n    initial begin\n        led_o   = 1'b0;\n        counter = '0;\n    end\n\nendmodule"
  },
  {
    "objectID": "labs.html#lab-2---multiplexed-7-segment-display",
    "href": "labs.html#lab-2---multiplexed-7-segment-display",
    "title": "E155 Labs",
    "section": "Lab 2 - Multiplexed 7-Segment Display",
    "text": "Lab 2 - Multiplexed 7-Segment Display\n\nIntroduction\nIn this lab I implemented a design on the FPGA board to demonstrate the functionality of a time multiplexed 7-segment display. The design uses the on board high-speed oscillator to create a clock signal, which is then divided down to achieve a refresh rate of approximately 120Hz for the display.\n\n\nDesign and Testing Methodology\nThe design was implemented and tested using a combination of System Verilog for the hardware description and a testbench for simulation. The testbench generates the necessary clock and reset signals, and applies various input patterns to verify the correct operation of the 7-segment display driver. The submodules were also tested individually to ensure their functionality before integrating them into the top-level design.\nThe inputs of the design are two 4-bit binary switches. The outputs are the 7-segment display and two anode control signals. The design uses combinational logic to determine which segments of the display should be lit based on the binary input values. The two digits of the display are multiplexed, meaning that only one digit is lit at a time, but they are switched rapidly enough using an on board oscillator so that both segments appear to be lit simultaneously to the human eye.\nSince humans are able to perceive flickering at around 60Hz, I aimed for a refresh rate of 120Hz to ensure that the display appears stable. Given that there are two digits to be multiplexed, each digit needs to be refreshed at 60Hz. Therefore, the clock divider was designed to divide the 48MHz clock from the on board oscillator down to 120Hz. I did this by setting the counter to count to 400,000. This is because 48,000,000 / 400,000 = 120.\n\n\nTechnical Documentation\nThe source code for my project can be found at this GitHub repository.\n\nBlock Diagram\n\n\n\nBlock Diagram for Verilog Design\n\n\nThe block diagram illustrates the overall architecture of the System Verilog design. The top module (lab2_CJ) initializes the on board oscillator and instantiates the submodules. The submodules (two_input_led_adder, segment, encoder, and decoder) include the logic for controlling which switches are used, choosing which segments to light up, and generating the output for the LEDs.\n\n\nSchematic\n\n\n\nSchematic of Physical Implementation\n\n\nThe schematic provides a detailed view of the physical connections between the switches, FPGA, 7-segment display, and LEDs. Each switch has a 100k\\(\\ohm\\) pull-up resistor to ensure a defined logic level when the switch is open. The 7-segment display and Red LEDs are connected to the FPGA through 1k\\(\\ohm\\) current-limiting resistors to ensure current draw within the recommended range. The PNP transistors are used to switch the common anode of each digit on the 7-segment display and are connected to the FPGA through 1k\\(\\ohm\\) resistors to limit the base current.\nBase resistor calculation for PNP transistor: \\[\nV = 4.3V - V_{\\text{difference}} = (4.3 - 0.7)V = 3.6V\n\\]\n\\[\nV = IR \\implies R = \\frac{V}{I} = \\frac{3.6V}{0.008A} \\approx  450\\Omega\n\\]\nThus, we need a resistor value of at least 450\\(\\ohm\\) to ensure the base current does not exceed 8mA. I chose to use a 1k\\(\\ohm\\) resistor to be safe.\nLED resistor calculation: \\[\nI = \\frac{V}{R} = \\frac{4.3V - 1.7V}{1k\\Omega} = 2.6mA\n\\]\nSegment resistor calculation: \\[\nI = \\frac{V}{R} = \\frac{4.3V - 2.0V}{1k\\Omega} = 2.3mA\n\\]\n\n\n\nResults and Discussion\nUnfortunately, I was not able to get the segmentation design to work on the FPGA board. However, I was able to simulate the design in ModelSim and verify that it works as intended. Below the are screenshots from ModelSim showing the simulation results for the top module and each submodule.\n\n\n\nScreenshot of Questa ModelSim Simulation for lab2_CJ top module\n\n\n\n\n\nScreenshot of Questa ModelSim Simulation for encoder module\n\n\n\n\n\nScreenshot of Questa ModelSim Simulation for decoder module\n\n\n\n\n\nScreenshot of Questa ModelSim Simulation for two_input_led_adder module\n\n\nAfter extensive debugging I determined that the anode1 and anode2 signals were being oscillated at a desired frequency. In addition each of the seg[0] - seg[6] signals were being driven to the correct values based on the input switches. However, despite this the 7-segment display is always on. This is becuase the base is always getting a low input which means the transistor is always on.\n\n\nConclusion\nIn conclusion, while I was unable to implement the segmentation design on the FPGA board, the simulation results in ModelSim confirmed the design’s functionality. The screenshots provided demonstrate the expected behavior of the top module and its submodules, validating the design approach.\nHours in lab: 18\n\n\nAI Prototype Summary\nThe AI prototype I used for this lab was ChatGPT 4.1. I used it to generate the System Verilog code for the top module of the design with the given prompt. With both prompts the code generated was able to synthesize without any substantial errors. However, the design did not make use of the on board oscillator. When looking at the Netlist Analyzer the design was far different from the one I created. Additionally, the design toggled the segments at every clock cycle which would not be visible to the human eye.\nWhen Passing in no context to ChatGPT 4.1 it generated the following System Verilog code for the top module:\nmodule multiplexed_seven_segment (\n    input  logic        clk,         // Clock input for multiplexing\n    input  logic        rst_n,       // Active low reset\n    input  logic [3:0]  in0,         // First 4-bit input\n    input  logic [3:0]  in1,         // Second 4-bit input\n    output logic [6:0]  seg0,        // Seven segment output for first display\n    output logic [6:0]  seg1         // Seven segment output for second display\n);\n\n    // Internal signals\n    logic        sel;                  // Multiplex selector\n    logic [3:0]  mux_in;               // Selected input\n    logic [6:0]  decoded;              // Decoded output\n\n    // Multiplex selector flips every clock cycle\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            sel &lt;= 1'b0;\n        else\n            sel &lt;= ~sel;\n    end\n\n    // Select input based on sel\n    always_comb begin\n        mux_in = (sel) ? in1 : in0;\n    end\n\n    // Seven segment decoder (common anode: segment ON = 0)\n    always_comb begin\n        case (mux_in)\n            4'h0: decoded = 7'b0000001;\n            4'h1: decoded = 7'b1001111;\n            4'h2: decoded = 7'b0010010;\n            4'h3: decoded = 7'b0000110;\n            4'h4: decoded = 7'b1001100;\n            4'h5: decoded = 7'b0100100;\n            4'h6: decoded = 7'b0100000;\n            4'h7: decoded = 7'b0001111;\n            4'h8: decoded = 7'b0000000;\n            4'h9: decoded = 7'b0000100;\n            4'hA: decoded = 7'b0001000;\n            4'hB: decoded = 7'b1100000;\n            4'hC: decoded = 7'b0110001;\n            4'hD: decoded = 7'b1000010;\n            4'hE: decoded = 7'b0110000;\n            4'hF: decoded = 7'b0111000;\n            default: decoded = 7'b1111111;\n        endcase\n    end\n\n    // Latch decoded value for each output on alternate clock edges\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            seg0 &lt;= 7'b1111111;\n            seg1 &lt;= 7'b1111111;\n        end else begin\n            if (sel)\n                seg1 &lt;= decoded;\n            else\n                seg0 &lt;= decoded;\n        end\n    end\n\nendmodule\nWhen passing in context of the previous lab ChatGPT 4.1 generated the following System Verilog code for the top module:\nmodule seven_seg_mux (\n    input  logic clk,                  // Oscillator clock input\n    input  logic [3:0] in0,            // First 4-bit input\n    input  logic [3:0] in1,            // Second 4-bit input\n    output logic [6:0] seg0,           // First 7-segment output\n    output logic [6:0] seg1            // Second 7-segment output\n);\n\n    logic [3:0] mux_in;\n    logic [6:0] seg_out;\n    logic mux_sel;\n\n    // Simple clock divider for multiplexing (you may adjust division factor)\n    logic [15:0] div_cnt;\n    always_ff @(posedge clk) begin\n        div_cnt &lt;= div_cnt + 1;\n        mux_sel &lt;= div_cnt[15]; // Use MSB for slow mux select signal\n    end\n\n    // Multiplex input selection\n    always_comb begin\n        mux_in = mux_sel ? in1 : in0;\n    end\n\n    // Instantiate the seven segment decoder\n    seven_segment_decoder decoder_inst (\n        .bin_in(mux_in),\n        .seg_out(seg_out)\n    );\n\n    // Latch outputs for display persistence\n    always_ff @(posedge clk) begin\n        if (mux_sel)\n            seg1 &lt;= seg_out;\n        else\n            seg0 &lt;= seg_out;\n    end\n\nendmodule"
  },
  {
    "objectID": "labs.html#lab-3---keypad-scanner",
    "href": "labs.html#lab-3---keypad-scanner",
    "title": "E155 Labs",
    "section": "Lab 3 - Keypad Scanner",
    "text": "Lab 3 - Keypad Scanner"
  },
  {
    "objectID": "labs.html#lab-4---digital-audio",
    "href": "labs.html#lab-4---digital-audio",
    "title": "E155 Labs",
    "section": "Lab 4 - Digital Audio",
    "text": "Lab 4 - Digital Audio"
  },
  {
    "objectID": "labs.html#lab-5---interrupts",
    "href": "labs.html#lab-5---interrupts",
    "title": "E155 Labs",
    "section": "Lab 5 - Interrupts",
    "text": "Lab 5 - Interrupts"
  },
  {
    "objectID": "labs.html#lab-6---the-internet-of-things-and-serial-peripheral-interface",
    "href": "labs.html#lab-6---the-internet-of-things-and-serial-peripheral-interface",
    "title": "E155 Labs",
    "section": "Lab 6 - The Internet of Things and Serial Peripheral Interface",
    "text": "Lab 6 - The Internet of Things and Serial Peripheral Interface"
  },
  {
    "objectID": "labs.html#lab-7---the-advanced-encryption-standard-aes",
    "href": "labs.html#lab-7---the-advanced-encryption-standard-aes",
    "title": "E155 Labs",
    "section": "Lab 7 - The Advanced Encryption Standard (AES)",
    "text": "Lab 7 - The Advanced Encryption Standard (AES)"
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "E155 Resources",
    "section": "",
    "text": "The e155 website."
  }
]